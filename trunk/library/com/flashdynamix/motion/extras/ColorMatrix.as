package com.flashdynamix.motion.extras {	import flash.display.DisplayObject;	import flash.filters.ColorMatrixFilter;		import com.flashdynamix.motion.extras.Filter;		/**	 * @author shanem	 */	public class ColorMatrix extends Filter {
		private static const ID : Array = [1,0,0,0,0,										   0,1,0,0,0,										   0,0,1,0,0,										   0,0,0,1,0];
		private static const LUMA_R : Number = 0.212671;		private static const LUMA_G : Number = 0.715160;		private static const LUMA_B : Number = 0.072169;
		public var current : Array;		public var to : Array;		public var from : Array;
		private var _position : Number = 0;
		public function ColorMatrix(item : DisplayObject) {			current = ID.concat();			to = ID.concat();			from = ID.concat();						super(item, new ColorMatrixFilter(current));		}
		
		public function set position(num : Number) : void {			_position = num;						var q : Number = 1 - _position;			var len : int = to.length;						for(var i : int = 0;i < len; i++) {				current[i] = from[i] * q + to[i] * _position;			}						ColorMatrixFilter(filter).matrix = current;						refresh();		}
		public function get position() : Number {			return _position;		}
		public function colorize(color : uint, amount : Number = 1) : void { 			var r : Number = ((color >> 16) & 0xFF) / 255;			var g : Number = ((color >> 8) & 0xFF) / 255;			var b : Number = (color & 0xFF) / 255;			var q : Number = 1 - amount;						var trans : Array = [q + amount * r * LUMA_R, amount * r * LUMA_G, amount * r * LUMA_B, 0, 0,							  	 amount * g * LUMA_R, q + amount * g * LUMA_G, amount * g * LUMA_B, 0, 0,							  	 amount * b * LUMA_R, amount * b * LUMA_G, q + amount * b * LUMA_B, 0, 0,							  	 0, 0, 0, 1, 0];					apply(trans);		}
		public function threshold(amount : Number) : void {			var trans : Array = [LUMA_R * 256, LUMA_G * 256, LUMA_B * 256, 0,  -256 * amount, 								 LUMA_R * 256, LUMA_G * 256, LUMA_B * 256, 0,  -256 * amount, 								 LUMA_R * 256, LUMA_G * 256, LUMA_B * 256, 0,  -256 * amount, 								 0, 0, 0, 1, 0]; 			apply(trans);		}
		public function hue(degree : Number) : void {			degree *= Math.PI / 180;						var cos : Number = Math.cos(degree);			var sin : Number = Math.sin(degree);						var trans : Array = [((LUMA_R + (cos * (1 - LUMA_R))) + (sin * -(LUMA_R))), ((LUMA_G + (cos * -(LUMA_G))) + (sin * -(LUMA_G))), ((LUMA_B + (cos * -(LUMA_B))) + (sin * (1 - LUMA_B))), 0, 0,             		((LUMA_R + (cos * -(LUMA_R))) + (sin * 0.143)), ((LUMA_G + (cos * (1 - LUMA_G))) + (sin * 0.14)), ((LUMA_B + (cos * -(LUMA_B))) + (sin * -0.283)), 0, 0,             		((LUMA_R + (cos * -(LUMA_R))) + (sin * -((1 - LUMA_R)))), ((LUMA_G + (cos * -(LUMA_G))) + (sin * LUMA_G)), ((LUMA_B + (cos * (1 - LUMA_B))) + (sin * LUMA_B)), 0, 0,             		0, 0, 0, 1, 0];			apply(trans);		}
		public function brightness(offset : Number) : void {			offset = (offset * 255) - 255;						var trans : Array = [1,0,0,0,offset,								 0,1,0,0,offset,								 0,0,1,0,offset,								 0,0,0,1,0,								 0,0,0,0,1];			apply(trans);		}
		public function saturation(offset : Number) : void {			var q : Number = 1 - offset;			var r : Number = q * LUMA_R;			var g : Number = q * LUMA_G;			var b : Number = q * LUMA_B;						var trans : Array = [r + offset, g , b , 0, 0,							  	 r, g + offset, b, 0, 0,							  	 r, g, b + offset, 0, 0,							  	 0, 0, 0, 1, 0];			apply(trans);		}
		public function contrast(offset : Number) : void {			var q : Number = 1 - offset;						var trans : Array = [offset,0,0,0,128 * q,							   	 0,offset,0,0,128 * q,							   	 0,0,offset,0,128 * q,							   	 0,0,0,1,0];			apply(trans);		}
		private function apply(mtx : Array) : void {			var trans : Array = [];			var i : int = 0;			var x : int;			var y : int;			var z : int = 0;						for (y = 0;y < 4; y++) {				for (x = 0;x < 5; x++) {					if (x == 4) {						z = mtx[i + 4];					} else {						z = 0;					}					trans[i + x] = mtx[i] * to[x] + mtx[i + 1] * to[x + 5] + mtx[i + 2] * to[x + 10] + mtx[i + 3] * to[x + 15] + z;				}				i += 5;			}						to = trans;		}	}}